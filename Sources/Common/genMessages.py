#! /usr/bin/env python

import sys
from xml.dom import minidom

messagesHpp = open("Messages/Messages.hpp", "w")
messages = minidom.parse('Messages/Messages.xml')

def convertToCppType(xmlType):
	if xmlType == "boolean":
		return "bool"
	elif xmlType == "string":
		return "std::string"
	elif xmlType == "int32":
		return "int"
	else:
		print "unknown param type: " + xmlType + "!"
		sys.exit(1)


def genHeader():
	messagesHpp.write(
		"/* this file is autogenerated, do not edit! */\n\n"
		"#ifndef COMMON_MESSAGES_HPP\n"
		"#define COMMON_MESSAGES_HPP\n\n"
		"#include <exception>\n"
		"#include <vector>\n"
		"#include <string>\n"
		"#include <ostream>\n"
		"#include <memory>\n\n"
		"#include <RustedCodec/IWriteBuffer.hpp>\n"
		"#include <RustedCodec/IReadBuffer.hpp>\n\n"
		"#include <RustedCodec/RustedAbstractDecoder.hpp>\n"
		"#include <RustedCodec/RustedAbstractCoder.hpp>\n\n"
		"namespace Common \n{\n"
		"namespace Messages \n{\n\n"
	)

	# write messages enum
	messagesHpp.write("namespace Id\n{\n")
	messagesHpp.write("enum Messages\n{\n")
	for message in messages.childNodes[0].getElementsByTagName("message"):
		messagesHpp.write("\t" + message.getAttribute("id") + ",\n")
	messagesHpp.write("\tDUMMY // message generator issue, don't ask why\n};\n");
	messagesHpp.write("}\n\n")


def genAbstractMessage():
	# message inteface
	messagesHpp.write(
		"struct AbstractMessage\n{\n"
		"\tvirtual Id::Messages getId() const = 0 ;\n"
		"\tvirtual void serialize(::Common::RustedCodec::IWriteBuffer & buf) = 0;\n"
		"};\n\n"
	)
	

def genMessageParam(param):
	messagesHpp.write("\t")
	messagesHpp.write(convertToCppType(param.getAttribute("type")) + " " + param.getAttribute("name") + ";\n")


def genMessageList(list_type):
	messagesHpp.write("\tstd::vector<boost::tuple<")
	for i, list_type_item in enumerate(list_type.getElementsByTagName("listparam")):
		messagesHpp.write(convertToCppType(list_type_item.getAttribute("type")))
		if i < len(list_type.getElementsByTagName("listparam")) - 1:
			messagesHpp.write(", ")
	messagesHpp.write("> > " + list_type.getAttribute("name") + ";\n")


def genMessageStruct(message):
	messagesHpp.write("struct " + message.getAttribute("id") + " : public AbstractMessage\n{\n")
	messagesHpp.write("\tId::Messages getId() const { return Id::" + message.getAttribute("id") + "; }\n")
	print "generating " + message.getAttribute("id")
	for param in message.getElementsByTagName("param"):
		genMessageParam(param);

	lists = message.getElementsByTagName("list") 
	for list_type in lists:
		genMessageList(list_type)
	
	# coder function
	messagesHpp.write(
		"\n"
		"\tvoid serialize(Common::RustedCodec::IWriteBuffer & buf)\n\t{\n"
		"\t\tCommon::RustedCodec::RustedAbstractCoder coder(buf);\n"
		"\t\tcoder\n"
		"\t\t\t<< Id::" + message.getAttribute("id") + "\n"
	)
	
	for param in message.getElementsByTagName("param"):
		messagesHpp.write("\t\t\t<< " + param.getAttribute("name") + "\n")

	for listParam in message.getElementsByTagName("list"):
		messagesHpp.write("\t\t\t<< " + listParam.getAttribute("name") + "\n")
	
	messagesHpp.write("\t\t;\n\t}\n\n")
	messagesHpp.write("};\n\n");


def genPrintOperator(message):
	messagesHpp.write(
		"\n"
		"inline std::ostream & operator<<(std::ostream & os, const " + message.getAttribute("id") + " & msg)\n"
		"{\n"
		"\tos\n"
	)
	
	messagesHpp.write("\t\t<< \"" + message.getAttribute("id") + "\\n{\\n\"")

	for param in message.getElementsByTagName("param"):
		messagesHpp.write("\t\t<< \"  " + param.getAttribute("name") + ": \" << msg." + param.getAttribute("name") + " << \"\\n\"\n")

#	for listParam in message.getElementsByTagName("list"):
#		messagesHpp.write("\t\t\t<< " + listParam.getAttribute("name") + "\n")

	messagesHpp.write("\t\t<< \"}\\n\";\n")
	messagesHpp.write("\treturn os;\n")
	messagesHpp.write("}\n\n")


def genStructs():
	for message in messages.childNodes[0].getElementsByTagName("message"):
		genMessageStruct(message);
		genPrintOperator(message);

	
def genMessageFactory():
	messagesHpp.write(
		"class MessageFactory\n"
		"{\n"
		"public:\n"
		"\tstatic std::auto_ptr<AbstractMessage> create(::Common::RustedCodec::IReadBuffer & buf)\n\t{\n"
		"\t\t::Common::RustedCodec::RustedAbstractDecoder decoder(buf);\n"
		"\t\tstd::auto_ptr<AbstractMessage> message;\n"
		"\t\tint id;\n"
		"\t\tdecoder >> id;\n"
		"\t\tswitch (id)\n"
		"\t\t{\n"
	)

	# decode stuff

	for message in messages.childNodes[0].getElementsByTagName("message"):
		messagesHpp.write(
			"\t\t\tcase Id::" + message.getAttribute("id") + ":\n"
			"\t\t\t\tmessage.reset(new " + message.getAttribute("id") + "());\n"
		)

		if message.getElementsByTagName("param").length > 0 or message.getElementsByTagName("list").length > 0:
			# decoder function
			messagesHpp.write(
				"\t\t\t\tdecoder\n"
			)
	
			for param in message.getElementsByTagName("param"):
				messagesHpp.write("\t\t\t\t\t>> static_cast<" + message.getAttribute("id") + " *>(message.get())->" + param.getAttribute("name") + "\n")

			for listParam in message.getElementsByTagName("list"):
				messagesHpp.write("\t\t\t\t\t>> static_cast<" + message.getAttribute("id") + " *>(message.get())->" + listParam.getAttribute("name") + "\n")

			messagesHpp.write("\t\t\t\t;\n")

		messagesHpp.write(
			"\t\t\t\tbreak;\n"
		)

	messagesHpp.write(
		"\t\t\tdefault: throw std::exception();\n"
		"\t\t}\n"
		"\t\treturn message;\n"
		"\t}\n};\n\n"
	)

def genHandlerCaller(parameterCount):
    messagesHpp.write(
        "template <typename HandlerType" 
    )

    for i in range(parameterCount):
        messagesHpp.write(", typename T" + str(i));

    messagesHpp.write(
        ">\n"
        "class HandlerCaller" + str(parameterCount) + "\n"
        "{\n"
        "public:\n"
        "\tHandlerCaller" + str(parameterCount) + "(HandlerType & handler) : m_handler(handler) {}\n"
    )
    messagesHpp.write(
        "\tvoid call(AbstractMessage & message"
    )

    for i in range(parameterCount):
        messagesHpp.write(", T" + str(i) + " p" + str(i));

    messagesHpp.write(")\n")

    messagesHpp.write(    
        "\t{\n"
        "\t\tswitch (message.getId())\n"
        "\t\t{\n"
    )

    for message in messages.childNodes[0].getElementsByTagName("message"):
        messagesHpp.write(
            "\t\t\tcase Id::" + message.getAttribute("id") + ": m_handler.handle( static_cast<const " + message.getAttribute("id") + " &>(message)"
        ) 

        for i in range(parameterCount):
            messagesHpp.write(", p" + str(i));

        messagesHpp.write(
            "); break;\n"
        )

    messagesHpp.write(
        "\t\t\tdefault: throw std::exception();\n"
        "\t\t}\n"
        "\t}\n\n"
    )

    messagesHpp.write(
        "private:\n"
        "\tHandlerType & m_handler;\n"
        "};\n\n"
    )

def genFooter():
	messagesHpp.write("}\n}\n\n#endif\n");

def genAbstractPrintFunction():
	messagesHpp.write(
		"\n"
		"inline std::ostream & operator<<(std::ostream & os, const AbstractMessage & msg)\n{\n"
		"\tswitch (msg.getId())\n"
		"\t{\n"
	)

	for message in messages.childNodes[0].getElementsByTagName("message"):
		messagesHpp.write(
			"\t\tcase Id::" + message.getAttribute("id") + ": os << static_cast<const " + message.getAttribute("id") + " &>(msg); break;\n"
		)

	
	messagesHpp.write("\tdefault: throw std::exception();\n\t}\n")
	messagesHpp.write("\treturn os;\n")	
	messagesHpp.write("}\n\n")


genHeader()
genAbstractMessage()
genStructs()
genMessageFactory()
for i in range(5):
    genHandlerCaller(i)
genAbstractPrintFunction()
genFooter()

