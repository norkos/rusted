/* this file is autogenerated, do not edit! */

#pragma once

#include <stdexcept>
#include <vector>
#include <string>
#include <ostream>
#include <sstream>
#include <memory>

#include <Cake/Networking/Protocol/IWriteBuffer.hpp>
#include <Cake/Networking/Protocol/IReadBuffer.hpp>
#include "Cake/Networking/Protocol/BinaryCoder.hpp"
#include "Cake/Networking/Protocol/BinaryDecoder.hpp"
#include "Cake/Networking/Protocol/FcDecoder.hpp"
namespace Common{
namespace Messages{


namespace Id
{
enum Messages
{
	InvalidMessage = 0,
	ServerVersionReq = 100,
	ServerVersionResp = 101,
	Exception = 102,
	UserAuthorizationReq = 103,
	UserAuthorizationResp = 104,
	GetPlayerResourcesInfo = 105,
	PlayerResourcesInfo = 106,
	RustedTimeEpochReq = 107,
	RustedTimeEpochResp = 108,
	GetPlayerName = 109,
	PlayerName = 110,
	FetchPlayerShips = 111,
	PlayerShips = 112,
	ShipInfo = 113,
	ObjectIntegrity = 114,
	ChangeShipCourse = 115,
	ShipCourseInfo = 116,
	AsteroidInfo = 117,
	GetVisibleObjects = 118,
	VisibleObjects = 119,
	GetObjectInfo = 120,
	FocusObject = 121,
	SelectObject = 122,
	ObjectCargoInfo = 123,
	FetchAvailableActions = 124,
	AvailableActions = 125,
	ExecuteAction = 126,
	ActionStarted = 127,
	ActionFinished = 128,
	ActionCooldownExpired = 129,
	GlobalCooldownActivated = 130,
	GlobalCooldownExpired = 131,
	EmitMovingMeshEffect = 132,
	EmitExplosionEffect = 133,
	RealoadDatabase = 134
}; // enum
} // namespace Id

struct ISerializable
{
	virtual void serialize(Cake::Networking::Protocol::IWriteBuffer &) const = 0;
	virtual void unserialize(Cake::Networking::Protocol::IReadBuffer &) = 0;
	virtual void unserialize(const Cake::Serialization::Fc &) = 0;
	virtual std::string toString() const = 0;
};

struct AbstractMessage : public ISerializable
{
	virtual Id::Messages getId() const = 0;
};

struct ShipId : public ISerializable
{
	int id;

	// no list parameters

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ShipId ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct Position : public ISerializable
{
	int x;
	int y;
	int z;

	// no list parameters

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << x << y << z;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> x >> y >> z;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> x >> y >> z;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "Position ("
			<< "x:" << x << " "
			<< "y:" << y << " "
			<< "z:" << z << " "
			<< ")";
		return ss.str();
	}
};

struct ObjectId : public ISerializable
{
	int id;

	// no list parameters

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ObjectId ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct AvailableActionPlayerParameter : public ISerializable
{
	std::string name;

	// no list parameters

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << name;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> name;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> name;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "AvailableActionPlayerParameter ("
			<< "name:" << name << " "
			<< ")";
		return ss.str();
	}
};

struct AvailableAction : public ISerializable
{
	int id;
	int parameter;
	std::string name;
	std::string description;

	// no list parameters

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << id << parameter << name << description;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> parameter >> name >> description;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> parameter >> name >> description;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "AvailableAction ("
			<< "id:" << id << " "
			<< "parameter:" << parameter << " "
			<< "name:" << name << " "
			<< "description:" << description << " "
			<< ")";
		return ss.str();
	}
};

struct ServerVersionReq : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ServerVersionReq;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ServerVersionReq ("
			<< ")";
		return ss.str();
	}
};

struct ServerVersionResp : public AbstractMessage
{
	std::string version;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ServerVersionResp;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << version;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> version;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> version;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ServerVersionResp ("
			<< "version:" << version << " "
			<< ")";
		return ss.str();
	}
};

struct Exception : public AbstractMessage
{
	std::string description;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::Exception;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << description;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> description;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> description;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "Exception ("
			<< "description:" << description << " "
			<< ")";
		return ss.str();
	}
};

struct UserAuthorizationReq : public AbstractMessage
{
	std::string login;
	std::string password;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::UserAuthorizationReq;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << login << password;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> login >> password;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> login >> password;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "UserAuthorizationReq ("
			<< "login:" << login << " "
			<< "password:" << password << " "
			<< ")";
		return ss.str();
	}
};

struct UserAuthorizationResp : public AbstractMessage
{
	bool success;
	int player_id;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::UserAuthorizationResp;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << success << player_id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> success >> player_id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> success >> player_id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "UserAuthorizationResp ("
			<< "success:" << success << " "
			<< "player_id:" << player_id << " "
			<< ")";
		return ss.str();
	}
};

struct GetPlayerResourcesInfo : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GetPlayerResourcesInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GetPlayerResourcesInfo ("
			<< ")";
		return ss.str();
	}
};

struct PlayerResourcesInfo : public AbstractMessage
{
	int helium;
	int carbon;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::PlayerResourcesInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << helium << carbon;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> helium >> carbon;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> helium >> carbon;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "PlayerResourcesInfo ("
			<< "helium:" << helium << " "
			<< "carbon:" << carbon << " "
			<< ")";
		return ss.str();
	}
};

struct RustedTimeEpochReq : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::RustedTimeEpochReq;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "RustedTimeEpochReq ("
			<< ")";
		return ss.str();
	}
};

struct RustedTimeEpochResp : public AbstractMessage
{
	int seconds;
	int miliSeconds;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::RustedTimeEpochResp;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << seconds << miliSeconds;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> seconds >> miliSeconds;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> seconds >> miliSeconds;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "RustedTimeEpochResp ("
			<< "seconds:" << seconds << " "
			<< "miliSeconds:" << miliSeconds << " "
			<< ")";
		return ss.str();
	}
};

struct GetPlayerName : public AbstractMessage
{
	int id;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GetPlayerName;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GetPlayerName ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct PlayerName : public AbstractMessage
{
	int id;
	std::string name;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::PlayerName;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id << name;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> name;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> name;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "PlayerName ("
			<< "id:" << id << " "
			<< "name:" << name << " "
			<< ")";
		return ss.str();
	}
};

struct FetchPlayerShips : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::FetchPlayerShips;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "FetchPlayerShips ("
			<< ")";
		return ss.str();
	}
};

struct PlayerShips : public AbstractMessage
{
	// no parameters

	std::vector<ShipId> ships;

	Id::Messages getId() const
	{
		return Id::PlayerShips;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << ships;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> ships;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> ships;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "PlayerShips ("
			<< "ships (list)" << " "
			<< ")";
		return ss.str();
	}
};

struct ShipInfo : public AbstractMessage
{
	int id;
	int player_id;
	std::string model;
	int integrity;
	int speed;
	int x;
	int y;
	int z;
	float orientationW;
	float orientationX;
	float orientationY;
	float orientationZ;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ShipInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id << player_id << model << integrity << speed << x << y << z << orientationW << orientationX << orientationY << orientationZ;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> player_id >> model >> integrity >> speed >> x >> y >> z >> orientationW >> orientationX >> orientationY >> orientationZ;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> player_id >> model >> integrity >> speed >> x >> y >> z >> orientationW >> orientationX >> orientationY >> orientationZ;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ShipInfo ("
			<< "id:" << id << " "
			<< "player_id:" << player_id << " "
			<< "model:" << model << " "
			<< "integrity:" << integrity << " "
			<< "speed:" << speed << " "
			<< "x:" << x << " "
			<< "y:" << y << " "
			<< "z:" << z << " "
			<< "orientationW:" << orientationW << " "
			<< "orientationX:" << orientationX << " "
			<< "orientationY:" << orientationY << " "
			<< "orientationZ:" << orientationZ << " "
			<< ")";
		return ss.str();
	}
};

struct ObjectIntegrity : public AbstractMessage
{
	int id;
	int integrity;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ObjectIntegrity;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id << integrity;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> integrity;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> integrity;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ObjectIntegrity ("
			<< "id:" << id << " "
			<< "integrity:" << integrity << " "
			<< ")";
		return ss.str();
	}
};

struct ChangeShipCourse : public AbstractMessage
{
	int shipId;
	int x;
	int y;
	int z;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ChangeShipCourse;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << shipId << x << y << z;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> shipId >> x >> y >> z;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> shipId >> x >> y >> z;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ChangeShipCourse ("
			<< "shipId:" << shipId << " "
			<< "x:" << x << " "
			<< "y:" << y << " "
			<< "z:" << z << " "
			<< ")";
		return ss.str();
	}
};

struct ShipCourseInfo : public AbstractMessage
{
	int objectId;
	int startTimeSeconds;
	int startTimeMiliseconds;
	int initialSpeed;

	std::vector<Position> controlPoints;

	Id::Messages getId() const
	{
		return Id::ShipCourseInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objectId << startTimeSeconds << startTimeMiliseconds << initialSpeed << controlPoints;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objectId >> startTimeSeconds >> startTimeMiliseconds >> initialSpeed >> controlPoints;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objectId >> startTimeSeconds >> startTimeMiliseconds >> initialSpeed >> controlPoints;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ShipCourseInfo ("
			<< "objectId:" << objectId << " "
			<< "startTimeSeconds:" << startTimeSeconds << " "
			<< "startTimeMiliseconds:" << startTimeMiliseconds << " "
			<< "initialSpeed:" << initialSpeed << " "
			<< "controlPoints (list)" << " "
			<< ")";
		return ss.str();
	}
};

struct AsteroidInfo : public AbstractMessage
{
	int objectId;
	std::string model;
	int x;
	int y;
	int z;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::AsteroidInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objectId << model << x << y << z;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objectId >> model >> x >> y >> z;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objectId >> model >> x >> y >> z;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "AsteroidInfo ("
			<< "objectId:" << objectId << " "
			<< "model:" << model << " "
			<< "x:" << x << " "
			<< "y:" << y << " "
			<< "z:" << z << " "
			<< ")";
		return ss.str();
	}
};

struct GetVisibleObjects : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GetVisibleObjects;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GetVisibleObjects ("
			<< ")";
		return ss.str();
	}
};

struct VisibleObjects : public AbstractMessage
{
	// no parameters

	std::vector<ObjectId> objects;

	Id::Messages getId() const
	{
		return Id::VisibleObjects;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objects;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objects;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objects;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "VisibleObjects ("
			<< "objects (list)" << " "
			<< ")";
		return ss.str();
	}
};

struct GetObjectInfo : public AbstractMessage
{
	int id;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GetObjectInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GetObjectInfo ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct FocusObject : public AbstractMessage
{
	int id;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::FocusObject;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "FocusObject ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct SelectObject : public AbstractMessage
{
	int id;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::SelectObject;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "SelectObject ("
			<< "id:" << id << " "
			<< ")";
		return ss.str();
	}
};

struct ObjectCargoInfo : public AbstractMessage
{
	int id;
	int capacity;
	int carbon;
	int helium;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ObjectCargoInfo;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id << capacity << carbon << helium;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> capacity >> carbon >> helium;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> capacity >> carbon >> helium;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ObjectCargoInfo ("
			<< "id:" << id << " "
			<< "capacity:" << capacity << " "
			<< "carbon:" << carbon << " "
			<< "helium:" << helium << " "
			<< ")";
		return ss.str();
	}
};

struct FetchAvailableActions : public AbstractMessage
{
	int shipId;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::FetchAvailableActions;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << shipId;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> shipId;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> shipId;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "FetchAvailableActions ("
			<< "shipId:" << shipId << " "
			<< ")";
		return ss.str();
	}
};

struct AvailableActions : public AbstractMessage
{
	// no parameters

	std::vector<AvailableAction> actions;

	Id::Messages getId() const
	{
		return Id::AvailableActions;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << actions;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> actions;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> actions;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "AvailableActions ("
			<< "actions (list)" << " "
			<< ")";
		return ss.str();
	}
};

struct ExecuteAction : public AbstractMessage
{
	int id;
	int parameter;
	bool loop;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ExecuteAction;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << id << parameter << loop;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> id >> parameter >> loop;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> id >> parameter >> loop;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ExecuteAction ("
			<< "id:" << id << " "
			<< "parameter:" << parameter << " "
			<< "loop:" << loop << " "
			<< ")";
		return ss.str();
	}
};

struct ActionStarted : public AbstractMessage
{
	int objectId;
	int actionId;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ActionStarted;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objectId << actionId;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objectId >> actionId;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objectId >> actionId;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ActionStarted ("
			<< "objectId:" << objectId << " "
			<< "actionId:" << actionId << " "
			<< ")";
		return ss.str();
	}
};

struct ActionFinished : public AbstractMessage
{
	int objectId;
	int actionId;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ActionFinished;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objectId << actionId;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objectId >> actionId;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objectId >> actionId;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ActionFinished ("
			<< "objectId:" << objectId << " "
			<< "actionId:" << actionId << " "
			<< ")";
		return ss.str();
	}
};

struct ActionCooldownExpired : public AbstractMessage
{
	int actionId;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::ActionCooldownExpired;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << actionId;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> actionId;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> actionId;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "ActionCooldownExpired ("
			<< "actionId:" << actionId << " "
			<< ")";
		return ss.str();
	}
};

struct GlobalCooldownActivated : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GlobalCooldownActivated;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GlobalCooldownActivated ("
			<< ")";
		return ss.str();
	}
};

struct GlobalCooldownExpired : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::GlobalCooldownExpired;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "GlobalCooldownExpired ("
			<< ")";
		return ss.str();
	}
};

struct EmitMovingMeshEffect : public AbstractMessage
{
	int fromX;
	int fromY;
	int fromZ;
	int toX;
	int toY;
	int toZ;
	int speed;
	std::string mesh;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::EmitMovingMeshEffect;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << fromX << fromY << fromZ << toX << toY << toZ << speed << mesh;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> fromX >> fromY >> fromZ >> toX >> toY >> toZ >> speed >> mesh;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> fromX >> fromY >> fromZ >> toX >> toY >> toZ >> speed >> mesh;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "EmitMovingMeshEffect ("
			<< "fromX:" << fromX << " "
			<< "fromY:" << fromY << " "
			<< "fromZ:" << fromZ << " "
			<< "toX:" << toX << " "
			<< "toY:" << toY << " "
			<< "toZ:" << toZ << " "
			<< "speed:" << speed << " "
			<< "mesh:" << mesh << " "
			<< ")";
		return ss.str();
	}
};

struct EmitExplosionEffect : public AbstractMessage
{
	int objectId;
	int directionX;
	int directionY;
	int directionZ;

	// no list parameters

	Id::Messages getId() const
	{
		return Id::EmitExplosionEffect;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId() << objectId << directionX << directionY << directionZ;
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		decoder >> objectId >> directionX >> directionY >> directionZ;
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
		decoder >> objectId >> directionX >> directionY >> directionZ;
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "EmitExplosionEffect ("
			<< "objectId:" << objectId << " "
			<< "directionX:" << directionX << " "
			<< "directionY:" << directionY << " "
			<< "directionZ:" << directionZ << " "
			<< ")";
		return ss.str();
	}
};

struct RealoadDatabase : public AbstractMessage
{
	// no parameters

	// no list parameters

	Id::Messages getId() const
	{
		return Id::RealoadDatabase;
	}

	void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
	{
		Cake::Networking::Protocol::BinaryCoder coder(buffer);
		coder << getId();
	}

	void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
	}

	void unserialize(const Cake::Serialization::Fc & fc)
	{
		Cake::Networking::Protocol::FcDecoder decoder(fc);
	}

	std::string toString() const
	{
		std::stringstream ss;
		ss	<< "RealoadDatabase ("
			<< ")";
		return ss.str();
	}
};

class MessageFactory
{
public:
	static std::shared_ptr<AbstractMessage> create(Cake::Networking::Protocol::IReadBuffer & buffer)
	{
		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
		int id = Id::InvalidMessage;
		decoder >> id;
		std::shared_ptr<AbstractMessage> ret;

		switch(id)
		{
		case Id::ServerVersionReq:
			ret.reset(new ServerVersionReq());
			break;

		case Id::ServerVersionResp:
			ret.reset(new ServerVersionResp());
			break;

		case Id::Exception:
			ret.reset(new Exception());
			break;

		case Id::UserAuthorizationReq:
			ret.reset(new UserAuthorizationReq());
			break;

		case Id::UserAuthorizationResp:
			ret.reset(new UserAuthorizationResp());
			break;

		case Id::GetPlayerResourcesInfo:
			ret.reset(new GetPlayerResourcesInfo());
			break;

		case Id::PlayerResourcesInfo:
			ret.reset(new PlayerResourcesInfo());
			break;

		case Id::RustedTimeEpochReq:
			ret.reset(new RustedTimeEpochReq());
			break;

		case Id::RustedTimeEpochResp:
			ret.reset(new RustedTimeEpochResp());
			break;

		case Id::GetPlayerName:
			ret.reset(new GetPlayerName());
			break;

		case Id::PlayerName:
			ret.reset(new PlayerName());
			break;

		case Id::FetchPlayerShips:
			ret.reset(new FetchPlayerShips());
			break;

		case Id::PlayerShips:
			ret.reset(new PlayerShips());
			break;

		case Id::ShipInfo:
			ret.reset(new ShipInfo());
			break;

		case Id::ObjectIntegrity:
			ret.reset(new ObjectIntegrity());
			break;

		case Id::ChangeShipCourse:
			ret.reset(new ChangeShipCourse());
			break;

		case Id::ShipCourseInfo:
			ret.reset(new ShipCourseInfo());
			break;

		case Id::AsteroidInfo:
			ret.reset(new AsteroidInfo());
			break;

		case Id::GetVisibleObjects:
			ret.reset(new GetVisibleObjects());
			break;

		case Id::VisibleObjects:
			ret.reset(new VisibleObjects());
			break;

		case Id::GetObjectInfo:
			ret.reset(new GetObjectInfo());
			break;

		case Id::FocusObject:
			ret.reset(new FocusObject());
			break;

		case Id::SelectObject:
			ret.reset(new SelectObject());
			break;

		case Id::ObjectCargoInfo:
			ret.reset(new ObjectCargoInfo());
			break;

		case Id::FetchAvailableActions:
			ret.reset(new FetchAvailableActions());
			break;

		case Id::AvailableActions:
			ret.reset(new AvailableActions());
			break;

		case Id::ExecuteAction:
			ret.reset(new ExecuteAction());
			break;

		case Id::ActionStarted:
			ret.reset(new ActionStarted());
			break;

		case Id::ActionFinished:
			ret.reset(new ActionFinished());
			break;

		case Id::ActionCooldownExpired:
			ret.reset(new ActionCooldownExpired());
			break;

		case Id::GlobalCooldownActivated:
			ret.reset(new GlobalCooldownActivated());
			break;

		case Id::GlobalCooldownExpired:
			ret.reset(new GlobalCooldownExpired());
			break;

		case Id::EmitMovingMeshEffect:
			ret.reset(new EmitMovingMeshEffect());
			break;

		case Id::EmitExplosionEffect:
			ret.reset(new EmitExplosionEffect());
			break;

		case Id::RealoadDatabase:
			ret.reset(new RealoadDatabase());
			break;

		default:
			throw std::runtime_error("unknown message id");
		} // switch

		ret->unserialize(buffer);

		return ret;
	} // create

	static std::shared_ptr<AbstractMessage> create(const std::string & s)
	{
		std::shared_ptr<AbstractMessage> ret;
		Cake::Serialization::Fc fc(s);
		if (fc.getName() == "ServerVersionReq")
		{
			ret.reset(new ServerVersionReq());
		}
		if (fc.getName() == "ServerVersionResp")
		{
			ret.reset(new ServerVersionResp());
		}
		if (fc.getName() == "Exception")
		{
			ret.reset(new Exception());
		}
		if (fc.getName() == "UserAuthorizationReq")
		{
			ret.reset(new UserAuthorizationReq());
		}
		if (fc.getName() == "UserAuthorizationResp")
		{
			ret.reset(new UserAuthorizationResp());
		}
		if (fc.getName() == "GetPlayerResourcesInfo")
		{
			ret.reset(new GetPlayerResourcesInfo());
		}
		if (fc.getName() == "PlayerResourcesInfo")
		{
			ret.reset(new PlayerResourcesInfo());
		}
		if (fc.getName() == "RustedTimeEpochReq")
		{
			ret.reset(new RustedTimeEpochReq());
		}
		if (fc.getName() == "RustedTimeEpochResp")
		{
			ret.reset(new RustedTimeEpochResp());
		}
		if (fc.getName() == "GetPlayerName")
		{
			ret.reset(new GetPlayerName());
		}
		if (fc.getName() == "PlayerName")
		{
			ret.reset(new PlayerName());
		}
		if (fc.getName() == "FetchPlayerShips")
		{
			ret.reset(new FetchPlayerShips());
		}
		if (fc.getName() == "PlayerShips")
		{
			ret.reset(new PlayerShips());
		}
		if (fc.getName() == "ShipInfo")
		{
			ret.reset(new ShipInfo());
		}
		if (fc.getName() == "ObjectIntegrity")
		{
			ret.reset(new ObjectIntegrity());
		}
		if (fc.getName() == "ChangeShipCourse")
		{
			ret.reset(new ChangeShipCourse());
		}
		if (fc.getName() == "ShipCourseInfo")
		{
			ret.reset(new ShipCourseInfo());
		}
		if (fc.getName() == "AsteroidInfo")
		{
			ret.reset(new AsteroidInfo());
		}
		if (fc.getName() == "GetVisibleObjects")
		{
			ret.reset(new GetVisibleObjects());
		}
		if (fc.getName() == "VisibleObjects")
		{
			ret.reset(new VisibleObjects());
		}
		if (fc.getName() == "GetObjectInfo")
		{
			ret.reset(new GetObjectInfo());
		}
		if (fc.getName() == "FocusObject")
		{
			ret.reset(new FocusObject());
		}
		if (fc.getName() == "SelectObject")
		{
			ret.reset(new SelectObject());
		}
		if (fc.getName() == "ObjectCargoInfo")
		{
			ret.reset(new ObjectCargoInfo());
		}
		if (fc.getName() == "FetchAvailableActions")
		{
			ret.reset(new FetchAvailableActions());
		}
		if (fc.getName() == "AvailableActions")
		{
			ret.reset(new AvailableActions());
		}
		if (fc.getName() == "ExecuteAction")
		{
			ret.reset(new ExecuteAction());
		}
		if (fc.getName() == "ActionStarted")
		{
			ret.reset(new ActionStarted());
		}
		if (fc.getName() == "ActionFinished")
		{
			ret.reset(new ActionFinished());
		}
		if (fc.getName() == "ActionCooldownExpired")
		{
			ret.reset(new ActionCooldownExpired());
		}
		if (fc.getName() == "GlobalCooldownActivated")
		{
			ret.reset(new GlobalCooldownActivated());
		}
		if (fc.getName() == "GlobalCooldownExpired")
		{
			ret.reset(new GlobalCooldownExpired());
		}
		if (fc.getName() == "EmitMovingMeshEffect")
		{
			ret.reset(new EmitMovingMeshEffect());
		}
		if (fc.getName() == "EmitExplosionEffect")
		{
			ret.reset(new EmitExplosionEffect());
		}
		if (fc.getName() == "RealoadDatabase")
		{
			ret.reset(new RealoadDatabase());
		}
		ret->unserialize(fc);
		return ret;
	}
}; // class MessageFactory

template<class HandlerType>
struct HandlerCaller0
{
	HandlerCaller0(HandlerType & handler) :
	m_handler(handler)
	{
	}

	void call(AbstractMessage & message)
	{
		switch(message.getId())
		{
		case Id::ServerVersionReq:
			m_handler.handle(static_cast<const ServerVersionReq&>(message)); break;

		case Id::ServerVersionResp:
			m_handler.handle(static_cast<const ServerVersionResp&>(message)); break;

		case Id::Exception:
			m_handler.handle(static_cast<const Exception&>(message)); break;

		case Id::UserAuthorizationReq:
			m_handler.handle(static_cast<const UserAuthorizationReq&>(message)); break;

		case Id::UserAuthorizationResp:
			m_handler.handle(static_cast<const UserAuthorizationResp&>(message)); break;

		case Id::GetPlayerResourcesInfo:
			m_handler.handle(static_cast<const GetPlayerResourcesInfo&>(message)); break;

		case Id::PlayerResourcesInfo:
			m_handler.handle(static_cast<const PlayerResourcesInfo&>(message)); break;

		case Id::RustedTimeEpochReq:
			m_handler.handle(static_cast<const RustedTimeEpochReq&>(message)); break;

		case Id::RustedTimeEpochResp:
			m_handler.handle(static_cast<const RustedTimeEpochResp&>(message)); break;

		case Id::GetPlayerName:
			m_handler.handle(static_cast<const GetPlayerName&>(message)); break;

		case Id::PlayerName:
			m_handler.handle(static_cast<const PlayerName&>(message)); break;

		case Id::FetchPlayerShips:
			m_handler.handle(static_cast<const FetchPlayerShips&>(message)); break;

		case Id::PlayerShips:
			m_handler.handle(static_cast<const PlayerShips&>(message)); break;

		case Id::ShipInfo:
			m_handler.handle(static_cast<const ShipInfo&>(message)); break;

		case Id::ObjectIntegrity:
			m_handler.handle(static_cast<const ObjectIntegrity&>(message)); break;

		case Id::ChangeShipCourse:
			m_handler.handle(static_cast<const ChangeShipCourse&>(message)); break;

		case Id::ShipCourseInfo:
			m_handler.handle(static_cast<const ShipCourseInfo&>(message)); break;

		case Id::AsteroidInfo:
			m_handler.handle(static_cast<const AsteroidInfo&>(message)); break;

		case Id::GetVisibleObjects:
			m_handler.handle(static_cast<const GetVisibleObjects&>(message)); break;

		case Id::VisibleObjects:
			m_handler.handle(static_cast<const VisibleObjects&>(message)); break;

		case Id::GetObjectInfo:
			m_handler.handle(static_cast<const GetObjectInfo&>(message)); break;

		case Id::FocusObject:
			m_handler.handle(static_cast<const FocusObject&>(message)); break;

		case Id::SelectObject:
			m_handler.handle(static_cast<const SelectObject&>(message)); break;

		case Id::ObjectCargoInfo:
			m_handler.handle(static_cast<const ObjectCargoInfo&>(message)); break;

		case Id::FetchAvailableActions:
			m_handler.handle(static_cast<const FetchAvailableActions&>(message)); break;

		case Id::AvailableActions:
			m_handler.handle(static_cast<const AvailableActions&>(message)); break;

		case Id::ExecuteAction:
			m_handler.handle(static_cast<const ExecuteAction&>(message)); break;

		case Id::ActionStarted:
			m_handler.handle(static_cast<const ActionStarted&>(message)); break;

		case Id::ActionFinished:
			m_handler.handle(static_cast<const ActionFinished&>(message)); break;

		case Id::ActionCooldownExpired:
			m_handler.handle(static_cast<const ActionCooldownExpired&>(message)); break;

		case Id::GlobalCooldownActivated:
			m_handler.handle(static_cast<const GlobalCooldownActivated&>(message)); break;

		case Id::GlobalCooldownExpired:
			m_handler.handle(static_cast<const GlobalCooldownExpired&>(message)); break;

		case Id::EmitMovingMeshEffect:
			m_handler.handle(static_cast<const EmitMovingMeshEffect&>(message)); break;

		case Id::EmitExplosionEffect:
			m_handler.handle(static_cast<const EmitExplosionEffect&>(message)); break;

		case Id::RealoadDatabase:
			m_handler.handle(static_cast<const RealoadDatabase&>(message)); break;

		default:
			throw std::runtime_error("unknown message id");
		} // switch
	} // call

	private:
		HandlerType & m_handler;
}; // class HandlerCaller

template<class HandlerType, class T0>
struct HandlerCaller1
{
	HandlerCaller1(HandlerType & handler) :
	m_handler(handler)
	{
	}

	void call(AbstractMessage & message, T0 p0)
	{
		switch(message.getId())
		{
		case Id::ServerVersionReq:
			m_handler.handle(static_cast<const ServerVersionReq&>(message), p0); break;

		case Id::ServerVersionResp:
			m_handler.handle(static_cast<const ServerVersionResp&>(message), p0); break;

		case Id::Exception:
			m_handler.handle(static_cast<const Exception&>(message), p0); break;

		case Id::UserAuthorizationReq:
			m_handler.handle(static_cast<const UserAuthorizationReq&>(message), p0); break;

		case Id::UserAuthorizationResp:
			m_handler.handle(static_cast<const UserAuthorizationResp&>(message), p0); break;

		case Id::GetPlayerResourcesInfo:
			m_handler.handle(static_cast<const GetPlayerResourcesInfo&>(message), p0); break;

		case Id::PlayerResourcesInfo:
			m_handler.handle(static_cast<const PlayerResourcesInfo&>(message), p0); break;

		case Id::RustedTimeEpochReq:
			m_handler.handle(static_cast<const RustedTimeEpochReq&>(message), p0); break;

		case Id::RustedTimeEpochResp:
			m_handler.handle(static_cast<const RustedTimeEpochResp&>(message), p0); break;

		case Id::GetPlayerName:
			m_handler.handle(static_cast<const GetPlayerName&>(message), p0); break;

		case Id::PlayerName:
			m_handler.handle(static_cast<const PlayerName&>(message), p0); break;

		case Id::FetchPlayerShips:
			m_handler.handle(static_cast<const FetchPlayerShips&>(message), p0); break;

		case Id::PlayerShips:
			m_handler.handle(static_cast<const PlayerShips&>(message), p0); break;

		case Id::ShipInfo:
			m_handler.handle(static_cast<const ShipInfo&>(message), p0); break;

		case Id::ObjectIntegrity:
			m_handler.handle(static_cast<const ObjectIntegrity&>(message), p0); break;

		case Id::ChangeShipCourse:
			m_handler.handle(static_cast<const ChangeShipCourse&>(message), p0); break;

		case Id::ShipCourseInfo:
			m_handler.handle(static_cast<const ShipCourseInfo&>(message), p0); break;

		case Id::AsteroidInfo:
			m_handler.handle(static_cast<const AsteroidInfo&>(message), p0); break;

		case Id::GetVisibleObjects:
			m_handler.handle(static_cast<const GetVisibleObjects&>(message), p0); break;

		case Id::VisibleObjects:
			m_handler.handle(static_cast<const VisibleObjects&>(message), p0); break;

		case Id::GetObjectInfo:
			m_handler.handle(static_cast<const GetObjectInfo&>(message), p0); break;

		case Id::FocusObject:
			m_handler.handle(static_cast<const FocusObject&>(message), p0); break;

		case Id::SelectObject:
			m_handler.handle(static_cast<const SelectObject&>(message), p0); break;

		case Id::ObjectCargoInfo:
			m_handler.handle(static_cast<const ObjectCargoInfo&>(message), p0); break;

		case Id::FetchAvailableActions:
			m_handler.handle(static_cast<const FetchAvailableActions&>(message), p0); break;

		case Id::AvailableActions:
			m_handler.handle(static_cast<const AvailableActions&>(message), p0); break;

		case Id::ExecuteAction:
			m_handler.handle(static_cast<const ExecuteAction&>(message), p0); break;

		case Id::ActionStarted:
			m_handler.handle(static_cast<const ActionStarted&>(message), p0); break;

		case Id::ActionFinished:
			m_handler.handle(static_cast<const ActionFinished&>(message), p0); break;

		case Id::ActionCooldownExpired:
			m_handler.handle(static_cast<const ActionCooldownExpired&>(message), p0); break;

		case Id::GlobalCooldownActivated:
			m_handler.handle(static_cast<const GlobalCooldownActivated&>(message), p0); break;

		case Id::GlobalCooldownExpired:
			m_handler.handle(static_cast<const GlobalCooldownExpired&>(message), p0); break;

		case Id::EmitMovingMeshEffect:
			m_handler.handle(static_cast<const EmitMovingMeshEffect&>(message), p0); break;

		case Id::EmitExplosionEffect:
			m_handler.handle(static_cast<const EmitExplosionEffect&>(message), p0); break;

		case Id::RealoadDatabase:
			m_handler.handle(static_cast<const RealoadDatabase&>(message), p0); break;

		default:
			throw std::runtime_error("unknown message id");
		} // switch
	} // call

	private:
		HandlerType & m_handler;
}; // class HandlerCaller

inline std::ostream & operator << (std::ostream & stream, const AbstractMessage & message)
{
	return stream << message.toString();
}

} // namespace Common
} // namespace Messages

