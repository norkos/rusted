#! /usr/bin/env python

import sys
import argparse
from xml.dom import minidom

def convertToCppType(xmlType):
	if xmlType == "boolean":
		return "bool"
	elif xmlType == "string":
		return "std::string"
	elif xmlType == "int32":
		return "int"
	else:
		print "unknown param type: " + xmlType + "!"
		sys.exit(1)

class Param:
    def __init__(self, xml_node):
        self.name = xml_node.getAttribute("name")
        self.type = xml_node.getAttribute("type")
        self.cpp_type = convertToCppType(xml_node.getAttribute("type")) 

class List:
    def __init__(self, xml_node):
        self.name = xml_node.getAttribute("name")
        self.type = xml_node.getAttribute("type")
        self.xml_node = xml_node
        self.params = self.__parse_params()

    def __parse_params(self):
        params = []
        for listparam_xml_node in self.xml_node.getElementsByTagName("listparam"):
            param = Param(listparam_xml_node)
            params.append(param)
        return params

class Struct:
    def __init__(self, xml_node):
        self.xml_node = xml_node
        self.id = xml_node.getAttribute("id")
        self.params = self.__parse_params()
        self.lists = self.__parse_lists()

    def has_params(self):
        return len(self.params) > 0 or len(self.lists) > 0

    def __parse_params(self):
        params = []
        for param_xml_node in self.xml_node.getElementsByTagName("param"):
            param = Param(param_xml_node) 
            params.append(param)
        return params

    def __parse_lists(self):
        lists = []
        for list_xml_node in self.xml_node.getElementsByTagName("list"):
            list = List(list_xml_node)
            lists.append(list)
        return lists

class CppOutput:
    def __init__(self, structs, messages, output_file, namespace):
        self.output_file = output_file
        self.messages = messages
        self.structs = structs
        self.namespace = namespace.split("::")

        print("writing to " + self.output_file)
        print("namespace: " + str(self.namespace))

    def generate(self):
        self.f = open(self.output_file, "w")
        self.__write_header()
        self.__write_id_enum()
        self.__write_serializable()
        self.__write_abstract_message()
        self.__write_structs()
        self.__write_message_structs()
        self.__write_message_factory()
        self.__write_handler_caller()
        self.__write_print_operator()
        self.__write_footer()

    def __write_header(self):
        self.f.write(
            "/* this file is autogenerated, do not edit! */\n\n"
            "#pragma once\n"
            "\n"
            "#include <stdexcept>\n"
            "#include <vector>\n"
            "#include <string>\n"
            "#include <ostream>\n"
            "#include <sstream>\n"
            "#include <boost/shared_ptr.hpp>\n\n"
            "#include <Networking/Protocol/IWriteBuffer.hpp>\n"
            "#include <Networking/Protocol/IReadBuffer.hpp>\n"
            "#include \"Networking/Protocol/BinaryCoder.hpp\"\n"
            "#include \"Networking/Protocol/BinaryDecoder.hpp\"\n")

        for namespace in self.namespace:
            self.f.write("namespace " + namespace + "{\n")

        self.f.write("\n\n")

    def __write_id_enum(self):
        print("generating Id enum")
        self.f.write(
            "namespace Id\n"
            "{\n"
            "enum Messages\n"
            "{\n")

        id = 0
        print("\tInvalidMessage = " + str(id))
        self.f.write("\tInvalidMessage = " + str(id))

        id = 100
        for message in self.messages:
            print("\t" + message.id + " = " + str(id))
            self.f.write(",\n\t" + message.id + " = " + str(id))
            id = id + 1

        self.f.write(
            "\n}; // enum\n"
            "} // namespace Id\n"
            "\n")

    def __write_abstract_message(self):
        s = ""
        s = s + "struct AbstractMessage : public ISerializable\n"
        s = s + "{\n"
        s = s + "\tvirtual Id::Messages getId() const = 0;\n"
        s = s + "};\n"
        s = s + "\n"

        self.f.write(s)

    def __write_serializable(self):
        s = ""
        s = s + "struct ISerializable\n"
        s = s + "{\n"
        s = s + "\tvirtual void serialize(Cake::Networking::Protocol::IWriteBuffer &) const = 0;\n"
        s = s + "\tvirtual void unserialize(Cake::Networking::Protocol::IReadBuffer &) = 0;\n"
        s = s + "\tvirtual std::string toString() const = 0;\n"
        s = s + "};\n"
        s = s + "\n"

        self.f.write(s)

    def __write_structs(self):
        print("generating structures")
        for struct in self.structs:
            cpp_struct = CppStruct(struct, False)
            self.f.write(cpp_struct.generate())

    def __write_message_structs(self):
        print("generating message structures")
        for message in self.messages:
            cpp_struct = CppStruct(message, True)
            self.f.write(cpp_struct.generate())

    def __write_message_factory(self):
        print("generating message factory")
        message_factory = CppMessageFactory(self.messages)
        self.f.write(message_factory.generate())

    def __write_handler_caller(self):
        print("generating handler caller")
        handler_caller = CppHandlerCaller(self.messages)

        for i in range(2):
            self.f.write(handler_caller.generate(i))

    def __write_print_operator(self):
        s = ""
        s = s + "inline std::ostream & operator << (std::ostream & stream, const AbstractMessage & message)\n"
        s = s + "{\n"
        s = s + "\treturn stream << message.toString();\n"
        s = s + "}\n"
        s = s + "\n"
        self.f.write(s)

    def __write_footer(self):
        for namespace in self.namespace:
            self.f.write("} // namespace " + namespace + "\n")
        self.f.write("\n")

class CppStruct:
    def __init__(self, message, is_message):
        self.message = message
        self.is_message = is_message

    def generate(self):
        if self.is_message:
            print("\tmessage " + self.message.id)
            s = (
                "struct " + self.message.id + " : public AbstractMessage\n"
                "{\n"
            )
        else:
            print("\tstructure " + self.message.id)
            s = (
                "struct " + self.message.id + " : public ISerializable\n"
                "{\n"
            )

        s = s + self.__generate_params()
        s = s + self.__generate_lists()

        if self.is_message:
            s = s + self.__generate_getid_method()

        s = s + self.__generate_serialize_method()
        s = s + self.__generate_unserialize_method()
        s = s + self.__generate_to_string_method()

        s = s + (
            "};\n"
            "\n"
            )

        return s

    def __generate_getid_method(self):
        return (
            "\tId::Messages getId() const\n"
            "\t{\n"
            "\t\treturn Id::" + self.message.id + ";\n"
            "\t}\n"
            "\n"
            )

    def __generate_serialize_method(self):
        s = (
            "\tvoid serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const\n"
            "\t{\n"
            "\t\tCake::Networking::Protocol::BinaryCoder coder(buffer);\n"
            )

        if len(self.message.params) > 0 or len(self.message.lists) > 0 or self.is_message:
            s = s + "\t\tcoder"

            if self.is_message:
                s = s + " << getId()"

            for param in self.message.params:
                s = s + " << " + param.name

            for param in self.message.lists:
                s = s + " << " + param.name

            s = s + ";\n"

        s = s + (
            "\t}\n"
            "\n"
            )
        return s

    def __generate_unserialize_method(self):
        s = (
            "\tvoid unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)\n"
            "\t{\n"
            "\t\tCake::Networking::Protocol::BinaryDecoder decoder(buffer);\n"
            )

        if len(self.message.params) > 0 or len(self.message.lists) > 0:
            s = s + "\t\tdecoder"

            for param in self.message.params:
                s = s + " >> " + param.name

            for param in self.message.lists:
                s = s + " >> " + param.name

            s = s + ";\n"

        s = s + (
            "\t}\n"
            "\n"
            )
        return s

    def __generate_params(self):
        s = ""
        if len(self.message.params) == 0:
            s = "\t// no parameters\n"

        for param in self.message.params:
            print("\t\t" + param.name + ": " + param.type)
            s = s + (
                    "\t" + param.cpp_type + " " + param.name + ";\n"
            )
        s = s + "\n"
        return s

    def __generate_lists(self):
        s = ""
        if len(self.message.lists) == 0:
            s = "\t// no list parameters\n"

        for list in self.message.lists:
            print("\t\t" + list.name + ": list of " + list.type)
            s = s + "\tstd::vector<" + list.type + "> " + list.name + ";\n"

        s = s + "\n"
        return s

    def __generate_to_string_method(self):
        s = (
            "\tstd::string toString() const\n"
            "\t{\n"
            "\t\tstd::stringstream ss;\n"
            )

        s = s + "\t\tss\t<< \"" + self.message.id + " (\"\n"

        for param in self.message.params:
            s = s + "\t\t\t<< \"" + param.name + ":\" << " + param.name + " << \" \"\n"

        for list in self.message.lists:
            s = s + "\t\t\t<< \"" + list.name + " (list)\" << \" \"\n"

        s = s + "\t\t\t<< \")\";\n"

        s = s + (
            "\t\treturn ss.str();\n"
            "\t}\n"
            )
        return s

class CppMessageFactory:
    def __init__(self, messages):
        self.messages = messages

    def generate(self):
        s = ""
        s = s + self.__generate_header()

        for message in self.messages:
            s = s + self.__generate_message_case(message)

        s = s + self.__generate_footer()
        return s

    def __generate_header(self):
        s = ""
        s = s + "class MessageFactory\n"
        s = s + "{\n"
        s = s + "public:\n"
        s = s + "\tstatic boost::shared_ptr<AbstractMessage> create("
        s = s + "Cake::Networking::Protocol::IReadBuffer & buffer)\n"
        s = s + "\t{\n"
        s = s + "\t\tCake::Networking::Protocol::BinaryDecoder decoder(buffer);\n"
        s = s + "\t\tint id = Id::InvalidMessage;\n"
        s = s + "\t\tdecoder >> id;\n"
        s = s + "\t\tboost::shared_ptr<AbstractMessage> ret;\n"
        s = s + "\n"
        s = s + "\t\tswitch(id)\n"
        s = s + "\t\t{\n"
        return s

    def __generate_message_case(self, message):
        s = ""
        s = s + "\t\tcase Id::" + message.id + ":\n"
        s = s + "\t\t\tret.reset(new " + message.id + "());\n"
        s = s + "\t\t\tbreak;\n"
        s = s + "\n"
        return s

    def __generate_footer(self):
        s = ""
        s = s + "\t\tdefault:\n"
        s = s + "\t\t\tthrow std::runtime_error(\"unknown message id\");\n"
        s = s + "\t\t} // switch\n"
        s = s + "\n"
        s = s + "\t\tret->unserialize(buffer);\n"
        s = s + "\n"
        s = s + "\t\treturn ret;\n"
        s = s + "\t} // create\n"
        s = s + "}; // class MessageFactory\n"
        s = s + "\n"
        return s

class CppHandlerCaller:
    def __init__(self, messages):
        self.messages = messages

    def generate(self, parameter_count):
        s = ""
        s = s + self.__generate_header(parameter_count)

        for message in self.messages:
            s = s + self.__generate_message_case(parameter_count, message)

        s = s + self.__generate_footer()
        s = s + "\n"

        return s

    def __generate_header(self, parameter_count):
        s = ""
        s = s + "template<class HandlerType"

        for i in range(parameter_count):
            s = s + ", class T" + str(i)

        s = s + ">\n"
        s = s + "struct HandlerCaller" + str(parameter_count) + "\n"
        s = s + "{\n"
        s = s + "\tHandlerCaller" + str(parameter_count) + "(HandlerType & handler) :\n"
        s = s + "\tm_handler(handler)\n"
        s = s + "\t{\n"
        s = s + "\t}\n"
        s = s + "\n"
        s = s + "\tvoid call(AbstractMessage & message"

        for i in range(parameter_count):
            s = s + ", T" + str(i) + " p" + str(i)

        s = s + ")\n"
        s = s + "\t{\n"
        s = s + "\t\tswitch(message.getId())\n"
        s = s + "\t\t{\n"
        return s

    def __generate_message_case(self, parameter_count, message):
        s = ""
        s = s + "\t\tcase Id::" + message.id + ":\n"
        s = s + "\t\t\tm_handler.handle(static_cast<const " + message.id + "&>(message)"

        for i in range(parameter_count):
            s = s + ", p" + str(i)

        s = s + "); break;\n"
        s = s + "\n"

        return s

    def __generate_footer(self):
        s = ""
        s = s + "\t\tdefault:\n"
        s = s + "\t\t\tthrow std::runtime_error(\"unknown message id\");\n"
        s = s + "\t\t} // switch\n"
        s = s + "\t} // call\n"
        s = s + "\n"
        s = s + "\tprivate:\n"
        s = s + "\t\tHandlerType & m_handler;\n"
        s = s + "}; // class HandlerCaller\n"
        return s


parser = argparse.ArgumentParser()
parser.add_argument("-o", "--output", required=True)
parser.add_argument("-n", "--namespace", default="Cake::Networking::Protocol")
parser.add_argument("xml")
options = parser.parse_args()

print("reading " + options.xml)
messages = minidom.parse(options.xml)

structs = []
for struct_xml_node in messages.childNodes[0].getElementsByTagName("struct"):
    struct = Struct(struct_xml_node)
    structs.append(struct)

msgs = []
for message_xml_node in messages.childNodes[0].getElementsByTagName("message"):
    message = Struct(message_xml_node) 
    msgs.append(message)

hpp = CppOutput(structs, msgs, options.output, options.namespace)
hpp.generate()


